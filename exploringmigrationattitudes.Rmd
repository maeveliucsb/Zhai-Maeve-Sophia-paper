---
title: "Exploration_WVS"
output: html_document
date: "2025-02-12"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r library}
library(tidyverse) 
library(sf) 
library(here) 
library(stars) 
library(tmap) 
library(viridis) 
library(readr)
library(dplyr)
library(rnaturalearth)
library(rnaturalearthdata)
library(lubridate)
library(terra)
library(exactextractr)
library(readr)
library(ggplot2)
library (kableExtra)
library(countrycode)
library(geosphere)
```

```{r loading data}
#Loading data on migration
migration.raw <- read.csv("dataofmigration.csv")

country <- unique(migration.raw$Origin)
write.csv(country, "country.csv")

migration.raw[migration.raw$Origin == "Others",] <- NA

#Loading data from World Value Survey 2017
data.raw <- read.csv("wvs2017.csv")
#str(data.raw)

#Loading data for colonization
colonialismqog.raw <- read.csv("colonialism.csv")

# Reading colonization data
colonisation.dyads <- read.csv("COLDAT_dyads.csv")

colonisation.dyads <- colonisation.dyads %>%
  mutate(colonisation_years = colend_mean - colstart_mean)

# Renaming alternative colonization data
colonalismqog.df <- colonialismqog.raw %>%
  mutate(colonialnames = case_when(
    ht_colonial == 0 ~ "Never",
    ht_colonial == 1 ~ "Netherlands*",
    ht_colonial == 2 ~ "Spain*",
    ht_colonial == 3 ~ "Italy",
    ht_colonial == 4 ~ "United States of America*",
    ht_colonial == 5 ~ "United Kingdom*",
    ht_colonial == 6 ~ "France*",
    ht_colonial == 7 ~ "Portugal",
    ht_colonial == 8 ~ "Belgium",
    ht_colonial == 9 ~ "France*",
    ht_colonial == 10 ~ "Australia*"
  ))

```

# Section 1: Migration Flow

Note: The migration flow that I have created is only for 2024. The data lives in data/dataofmigration.csv, categorized in migration.raw. The migration data is derived from the International Organization of Migration.

## 1.1 merging migration data with colonization

```{r migration and colonization}
#Filtering for colonizers
migration1.df <- migration.raw %>%
  filter(Destination %in% c("Belgium", "United Kingdom*", "France*", "Germany", "Italy", "Netherlands*", "Portugal", "Spain*")) %>%
    mutate(Destination = gsub("\\*", "", Destination))

#Renaming colonizer to match
colonisation1.dyads <- colonisation.dyads %>%
  mutate(colonizer = case_when(
    colonizer == "belgium" ~ "Belgium",
    colonizer == "britain" ~ "United Kingdom",
    colonizer == "france" ~ "France",
    colonizer == "germany" ~ "Germany",
    colonizer == "italy" ~ "Italy",
    colonizer == "netherlands" ~ "Netherlands"
  ))
 
#Merging data with two conditions
migrationcolonizer.df <- migration1.df %>%
  left_join(colonisation1.dyads,
            by = c("Destination" = "colonizer", "Origin" = "country"),
            keep = TRUE)

#Column of colonizer
migrationcolonizer.df <- migrationcolonizer.df %>%
  mutate(colonizermatched = case_when(
    col == 1 ~ colonizer,
    TRUE ~ "None"
  ))

#Creating total proportion
migrationcolonizer.df <- migrationcolonizer.df %>%
  group_by(Destination) %>%
  mutate(X1990prop = X1990/sum(X1990, na.rm = TRUE),
         X1995prop = X1995/sum(X1995, na.rm = TRUE),
         X2000prop = X2000/sum(X2000, na.rm = TRUE),
         X2005prop = X2005/sum(X2005, na.rm = TRUE),
         X2010prop = X2010/sum(X2010, na.rm = TRUE),
         X2015prop = X2015/sum(X2015, na.rm = TRUE),
         X2020prop = X2020/sum(X2020, na.rm = TRUE),
         X2024prop = X2024/sum(X2024, na.rm = TRUE))

```

# Section 2: Distribution map of migration in 2024

## maeve maps! yippee :) 

```{r migration map in 2024}
# ------------------ Data ------------------
# Expectation: migration.raw has columns: Origin, Destination, X2024 (numeric)
# You already have: migration.raw
stopifnot(all(c("Origin","Destination","X2024") %in% names(migration.raw)))

mig <- migration.raw %>%
  mutate(
    X2024 = suppressWarnings(as.numeric(X2024))
  ) %>%
  filter(!is.na(X2024), X2024 > 0,
         !is.na(Origin), !is.na(Destination),
         Origin != Destination)

#Removing stars
mig <- mig %>%
      mutate(Destination = gsub("\\*", "", Destination),
             Origin = gsub("\\*", "", Origin))

# ------------------ Define "colonial powers" ------------------
# Tweak this vector if your definition differs.
colonial_powers_names <- c(
  "United Kingdom","France","Spain","Portugal","Netherlands",
  "Belgium","Italy","Germany","Denmark"
)
# Optional: include others if analytically justified:
# colonial_powers_names <- c(colonial_powers_names, "Russia", "Turkey", "United States")

# ------------------ Standardize country names -> ISO3 ------------------
# Handle common name issues via countrycode (add manual overrides as needed). FRA is missing
custom_map <- c(
  "Congo, Dem. Rep."       = "COD",
  "Congo, Rep."            = "COG",
  "Côte d’Ivoire"          = "CIV",
  "Cote d'Ivoire"          = "CIV",
  "Eswatini"               = "SWZ",
  "Kyrgyz Republic"        = "KGZ",
  "Korea, Rep."            = "KOR",
  "Korea, Dem. Rep."       = "PRK",
  "Lao PDR"                = "LAO",
  "Micronesia, Fed. Sts."  = "FSM",
  "Russian Federation"     = "RUS",
  "Syrian Arab Republic"   = "SYR",
  "United States of America" = "USA",
  "United States"          = "USA",
  "Viet Nam"               = "VNM",
  "France"  = "FRA"
)

to_iso3 <- function(x){
  iso <- countrycode(x, "country.name", "iso3c", warn = FALSE)
  # apply manual overrides where needed
  idx <- is.na(iso) & (x %in% names(custom_map))
  iso[idx] <- custom_map[x[idx]]
  iso
}

mig <- mig %>%
  mutate(
    origin_iso3 = to_iso3(Origin),
    dest_iso3   = to_iso3(Destination)
  ) %>%
  filter(!is.na(origin_iso3), !is.na(dest_iso3))

cp_iso3 <- to_iso3(colonial_powers_names)
cp_iso3 <- cp_iso3[!is.na(cp_iso3)]

# Keep flows where the origin is a colonial power
flows_cp <- mig %>%
  filter(origin_iso3 %in% cp_iso3) %>%
  group_by(origin_iso3, dest_iso3, Origin, Destination) %>%
  summarise(value_2024 = sum(X2024, na.rm = TRUE), .groups = "drop")

# ------------------ World geometries and centroids ------------------
world <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf") %>%
  st_transform(4326) %>%
  select(iso_a3, name, geometry)

world <- world %>%
  mutate(iso_a3 = case_when(
    name == "France" ~ "FRA",
    TRUE ~ iso_a3
  ))

# Use safe point-on-surface for label/centroid positions
world_pts <- world %>%
  mutate(centroid = st_point_on_surface(geometry)) %>%
  st_as_sf() %>%
  st_transform(4326) %>%
  st_drop_geometry() %>%
  select(iso_a3, name) %>%
  left_join(
    world %>%
      st_point_on_surface() %>%
      st_coordinates() %>%
      as.data.frame() %>%
      mutate(iso_a3 = world$iso_a3),
    by = "iso_a3"
  ) %>%
  rename(lon = X, lat = Y)

# Join coordinates for origins and destinations - ISSUE WITH FRANCE IS HERE
flows_coords <- flows_cp %>%
  left_join(world_pts %>% select(iso_a3, lon_o = lon, lat_o = lat),
            by = c("origin_iso3" = "iso_a3")) %>%
  left_join(world_pts %>% select(iso_a3, lon_d = lon, lat_d = lat),
            by = c("dest_iso3" = "iso_a3")) %>%
  filter(!is.na(lon_o), !is.na(lat_o), !is.na(lon_d), !is.na(lat_d))

# ------------------ Build great-circle lines ------------------
# For performance/readability, keep top N flows (adjust N)
N <- 300
flows_top <- flows_coords %>%
  arrange(desc(value_2024)) %>%
  slice_head(n = N)

# Create great-circle segments as sf MULTILINESTRING
gc_lines <- lapply(seq_len(nrow(flows_top)), function(i){
  p1 <- c(flows_top$lon_o[i], flows_top$lat_o[i])
  p2 <- c(flows_top$lon_d[i], flows_top$lat_d[i])
  # more points -> smoother arc
  gci <- geosphere::gcIntermediate(p1, p2, n = 50, addStartEnd = TRUE, breakAtDateLine = TRUE)
  # gcIntermediate returns either a matrix or a list (if dateline break)
  if (is.list(gci)) {
    parts <- lapply(gci, function(m) st_linestring(m))
    st_multilinestring(parts)
  } else {
    st_linestring(gci)
  }
})

flows_sf <- st_sf(
  origin = flows_top$Origin,
  destination = flows_top$Destination,
  origin_iso3 = flows_top$origin_iso3,
  dest_iso3   = flows_top$dest_iso3,
  value_2024  = flows_top$value_2024,
  geometry    = st_sfc(gc_lines, crs = 4326)
)

# Label colonial power (origin country) for color mapping
flows_sf <- flows_sf %>%
  mutate(origin_power = countrycode(origin_iso3, "iso3c", "country.name"))
library(scales)

# ------------------ Scaling for line width ------------------
# sqrt scaling helps compress the long tail
flows_sf <- flows_sf %>%
  mutate(
    lw = rescale(sqrt(value_2024), to = c(0.6, 6)) # adjust min/max widths if needed
  )

# ------------------ Basemap & destination points ------------------
dest_pts <- world_pts %>%
  inner_join(flows_sf %>% st_drop_geometry() %>% distinct(dest_iso3, destination),
             by = c("iso_a3" = "dest_iso3")) %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326, remove = FALSE)

origin_pts <- world_pts %>%
  inner_join(flows_sf %>% st_drop_geometry() %>% distinct(origin_iso3, origin_power),
             by = c("iso_a3" = "origin_iso3")) %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326, remove = FALSE)

# ------------------ Map (interactive) ------------------
tm_shape(world) + tm_polygons(col = "grey95", border.col = "white") +
  tm_shape(flows_sf) +
  tm_lines(
    lwd   = "lw",
    col   = "origin_power",
    alpha = 0.65,
    title.col = "Origin (colonial power)",
    legend.lwd.show = FALSE
  ) +
  tm_shape(dest_pts) +
  tm_dots(size = 0.04, col = "grey25", alpha = 0.8, shape = 21,
          title = "Destinations") +
  tm_shape(origin_pts) +
  tm_symbols(shape = 24, col = "black", size = 0.15, border.lwd = 0.5,
             legend.show = FALSE) +
  tm_layout(
    frame = FALSE,
    legend.outside = TRUE,
    legend.title.size = 1.0,
    legend.text.size  = 0.8,
    title = "Where people from colonial powers are going (2024 flows)"
  )

# ------------------ OPTIONAL: quick summary tables ------------------
# Top destinations by aggregate inflow from colonial powers
top_dest <- flows_cp %>%
  group_by(dest_iso3, Destination) %>%
  summarise(inflow_from_colonial = sum(value_2024), .groups = "drop") %>%
  arrange(desc(inflow_from_colonial)) %>%
  slice_head(n = 20)

print(top_dest)

# Flows by power -> destination (wide)
flows_wide <- flows_cp %>%
  mutate(origin_power = countrycode(origin_iso3, "iso3c", "country.name")) %>%
  group_by(origin_power, Destination) %>%
  summarise(value_2024 = sum(value_2024), .groups = "drop") %>%
  tidyr::pivot_wider(names_from = origin_power, values_from = value_2024, values_fill = 0)

 View(flows_wide)  # uncomment in RStudio

```

```{r migration map using tmap, Maeve to fix}
tmap_mode("view")

# Helper: available origins to pick from
available_powers <- sort(unique(flows_sf$origin_power))
print(available_powers)

#This is looking at how people are migration outwards, NOT inwards to colonial country.
make_map_view <- function(power){
  # 1) validate name (allow iso3 too)
  pow_iso <- tryCatch(countrycode(power, "country.name", "iso3c"), error = function(...) NA_character_)
  has_name <- power %in% flows_sf$origin_power
  has_iso  <- !is.na(pow_iso) && pow_iso %in% flows_sf$origin_iso3
  if (!has_name && !has_iso) {
    stop(sprintf("'%s' not found. Try one of: %s",
                 power, paste(available_powers, collapse = ", ")))
  }

  # 2) subset flows + points
  sub_flows <- dplyr::filter(
    flows_sf,
    if (has_name) origin_power == power else origin_iso3 == pow_iso
  )

  if (nrow(sub_flows) == 0 || length(sub_flows$geometry) == 0) {
    # graceful fallback: world only with a message
    message(sprintf("No flows for '%s' in flows_sf.", power))
    return(
      tm_shape(world) + tm_polygons(col = "grey95", border.col = "white") +
        tm_layout(frame = FALSE, title = sprintf("%s: no 2024 flows in data", power))
    )
  }

  sub_dest_iso <- unique(sub_flows$dest_iso3)
  sub_orig_iso <- unique(sub_flows$origin_iso3)

  sub_dest <- dplyr::filter(dest_pts, iso_a3 %in% sub_dest_iso)
  sub_orig <- dplyr::filter(origin_pts, iso_a3 %in% sub_orig_iso)

  # 3) zoom box (buffered bbox of flows)
  bbox <- sf::st_bbox(sf::st_transform(sub_flows, 4326))
  # pad a bit
  pad <- 3
  bbox[c("xmin","ymin","xmax","ymax")] <- c(bbox["xmin"]-pad, bbox["ymin"]-pad,
                                             bbox["xmax"]+pad, bbox["ymax"]+pad)

  # 4) build map
  tm_shape(world) + tm_polygons(col = "grey95", border.col = "white") +
    tm_shape(sub_flows) +
    tm_lines(lwd = "lw", col = "origin_power", alpha = 0.7, title.col = "Origin") +
    tm_shape(sub_dest) + tm_dots(size = 0.05, col = "grey25", alpha = 0.85, shape = 21) +
    tm_shape(sub_orig) + tm_symbols(shape = 24, col = "black", size = 0.18, border.lwd = 0.6) +
    tm_layout(frame = FALSE, legend.outside = TRUE,
              title = sprintf("%s: where people are going (2024)", power)) +
    tm_view(view.bounds = matrix(c(bbox["xmin"], bbox["ymin"],
                                   bbox["xmax"], bbox["ymax"]), ncol = 2, byrow = TRUE))
}


# Example calls (pick from printed available_powers):
<<<<<<< HEAD
make_map_view("Netherlands")
make_map_view("United Kingdom")
make_map_view("Spain")

```

## using the migration.dyad dataset, trying to fix the france issue. 

```{r}
colonial_empires <- c(
  "United Kingdom",
  "France",
  "Spain",
  "Portugal",
  "Netherlands",
  "Belgium"
)

flows <- migration.dyad %>%
  filter(Destination %in% colonial_empires) %>%
  rename(migrants = X2024)

world <- ne_countries(scale = "medium", returnclass = "sf")

# Centroids for connecting lines
centroids <- st_centroid(world) %>%
  select(name_long) %>%
  mutate(cx = st_coordinates(geometry)[,1],
         cy = st_coordinates(geometry)[,2]) %>%
  st_drop_geometry()

flows_sf <- flows %>%
  left_join(centroids, by = c("Origin" = "name_long")) %>%
  rename(ox = cx, oy = cy) %>%
  left_join(centroids, by = c("Destination" = "name_long")) %>%
  rename(dx = cx, dy = cy)

flows_sf <- flows_sf %>% filter(!is.na(ox) & !is.na(dx))

flows_lines <- flows_sf %>%
  rowwise() %>%
  mutate(
    geometry = st_sfc(
      st_linestring(
        rbind(c(ox, oy), c(dx, dy))
      ), crs = 4326
    )
  ) %>%
  st_as_sf()

flows_lines <- flows_lines %>%
  mutate(lw = rescale(sqrt(migrants), to = c(0.3, 3)))

bad_map <- ggplot() +
  geom_sf(data = world, fill = "gray90", color = "gray60", size = 0.1) +
  geom_sf(data = flows_lines,
          aes(size = lw),
          color = "firebrick",
          alpha = 0.7) +
  scale_size_identity() +
  labs(
    title = "Migration into Former Colonial Empires (2024)",
    subtitle = "Flows scaled using square-root transformation",
    caption = "Source: migration.dyad"
  ) +
  theme_minimal() +
  theme(
    panel.background = element_rect(fill = "white", color = NA),
    plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 12)
  )

bad_map
=======
make_map_view("Spain")
make_map_view("United Kingdom")
make_map_view("Portugal")
make_map_view("France")


```

# Section 3: Questions in World Value Survey

Migration
- Q121 Impact of immigrants on the development of the country
- Q122 Immigration in your country: Fills useful jobs in the workforce
- Q123 Immigration in your country: Strengthens cultural diversity
- Q124 Immigration in your country: Increases the crime rate
- Q125 Immigration in your country: Gives asylum to political refugees
- Q126 Immigration in your country: Increases the risks of terrorism
- Q127 Immigration in your country: Helps poor people establish new lives
- Q128 Immigration in your country: Increases unemployment
- Q129 Immigration in your country: Leads to social conflict
- Q130 Immigration policy preference

Control
- Q60: Trust: People you know personally
- Q61: Trust: People you meet for the first time
- Q62: Trust: People of another religion
- Q63: Trust: People of another nationality

# Appendix
## Appendix 1: Example dyads
The chunk below is analyzing in dyad, but please feel free to do something else.

```{r migration flows in 2024, echo=FALSE}
#Examining Understanding migration flows only for 2024
require(data.table)
dt <- data.table(migration.raw)
View(dt[, max(X2024), by = Origin])

max.migration <- data.frame(tapply(migration.raw$X2024, migration.raw$Origin, na.rm = TRUE))
max.migration

#Highest dyad of migration
# Convert to data.table
migrationdyad <- data.table(migration.raw)

# Get rows with the max value of X2024 for each Destination
migration.dyad <- migrationdyad[migrationdyad[, .I[which.max(X2024)], by = Destination]$V1]

# View result
View(migration.dyad)

View(table(migration.dyad$Origin))

#Dyad
# Ensure dyads are treated as unordered pairs
migrationdyad.df <- migration.raw %>%
  rowwise() %>%
  mutate(dyad = paste(sort(c(Origin, Destination)), collapse = "-")) %>%
  ungroup()

# Get the maximum value for each dyad
migration.result <- migrationdyad.df %>%
  group_by(dyad) %>%
  summarise(max_value = max(X2024))

View(migration.result)
#>>>>>>> 5fd1196d3932961d31462d3e87fe6f9b1dc132cc

```
#loading in shapefile

```{r}
file.exists("NUTS.shp")
nutsshp <- st_read("NUTS.shp")
getwd()
```
#loading in migration data
```{r}
library(haven)
biggroup<- read_dta("Biggest_group.dta")
view(biggroup)
names(biggroup)

```

## where everyone is coming from

```{r}

library(sf)
library(dplyr)
library(ggplot2)

class(nutsshp)
names(nutsshp)
grep("nuts|id|code", names(nutsshp), ignore.case = TRUE, value = TRUE)


# sanity checks: make sure both have NUTS_ID
# nutsshp <- nutsshp %>% rename(NUTS_ID = NUTS_BN_ID)
stopifnot("NUTS_ID" %in% names(nutsshp))
stopifnot("NUTS_ID" %in% names(biggroup))
stopifnot("group" %in% names(biggroup))

head(nutsshp$NUTS_ID)
head(biggroup$NUTS_ID)
sum(as.character(nutsshp$NUTS_ID) %in% as.character(biggroup$NUTS_ID))


nuts_map <- nutsshp %>%
  mutate(NUTS_ID = as.character(NUTS_ID)) %>%
  left_join(
    biggroup %>%
      mutate(NUTS_ID = as.character(NUTS_ID)) %>%
      select(NUTS_ID, agg_groups, group),
    by = "NUTS_ID"
  )
bb <- st_bbox(nuts_map)

pad_x <- as.numeric(bb["xmax"] - bb["xmin"]) * 0.10
pad_y <- as.numeric(bb["ymax"] - bb["ymin"]) * 0.10

ggplot(nuts_map) +
  geom_sf(aes(fill = group), color = "white", linewidth = 0.1) +
  coord_sf(
    xlim = c(bb["xmin"] + pad_x, bb["xmax"] - pad_x),
    ylim = c(bb["ymin"] + pad_y, bb["ymax"] - pad_y),
    datum = NA
  ) +
  labs(fill = "Majority immigrant origin group") +
  theme_minimal()

```

```{r}
library(tmap)

tmap_mode("plot")

tm_shape(nuts_map) +
  tm_polygons(
    fill = "group",
    col = "white",
    lwd = 0.1,
    title = "Majority immigrant origin group"
  ) +
  tm_layout(frame = FALSE, legend.outside = TRUE)

library(sf)
library(tmap)

tmap_mode("view")

nuts_map_ll <- st_transform(nuts_map, 4326)

tm_shape(nuts_map_ll) +
  tm_polygons(
    fill = "group",
    col = "white",
    lwd = 0.1,
    id = "NUTS_ID",
    popup.vars = c("NUTS_ID", "group"),
    title = "Majority immigrant origin group"
  ) +
  tm_basemap("CartoDB.Positron")

nuts_map_ll_s <- st_simplify(nuts_map_ll, dTolerance = 0.01, preserveTopology = TRUE)

tm_shape(nuts_map_ll_s) +
  tm_polygons(
    fill = "group",
    col = "white",
    lwd = 0.1,
    id = "NUTS_ID",
    popup.vars = c("NUTS_ID", "group")
  ) +
  tm_basemap("CartoDB.Positron")

```